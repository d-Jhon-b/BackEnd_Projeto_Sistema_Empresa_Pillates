from fastapi import APIRouter, Depends, HTTPException, status
from typing import Dict, Any, List
from pydantic import EmailStr, Field, BaseModel


# from src.model.configModel.all_user_config import UsuarioCompletoConfig 

from src.model.userModel import UserModel
from src.model.configModel.userSettings.valuesUser import NivelAcessoEnum

from src.model.configModel.typeUser.alunos import EstudanteConfig  
from src.model.configModel.typeUser.instrutor import ProfessorConfig 
from src.model.configModel.typeUser.adm import AdministracaoConfig 
# from src.model.configModel.userSettings.

from src.utils.authUtils import auth_manager



router = APIRouter(
    prefix="/users",
    tags=["Usuários"],
    responses={404: {"description": "Não encontrado"}},
)

def get_current_user_level() -> str:
    return NivelAcessoEnum.COLABORADOR.value


def require_user_creation_permission(user_level: str = Depends(get_current_user_level)):
    
    ALLOWED_LEVELS = [
        NivelAcessoEnum.COLABORADOR.value, 
        NivelAcessoEnum.SUPREMO.value 
    ]
    if user_level not in ALLOWED_LEVELS:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Permissão negada. Apenas {', '.join(ALLOWED_LEVELS)} podem criar novos usuários."
        )
    



def get_user_model(executor_level: str = Depends(get_current_user_level)) -> UserModel:
    return UserModel(executor_level)




@router.post(
    "/aluno", 
    status_code=status.HTTP_201_CREATED,
    response_model=Dict[str, Any], 
    dependencies=[Depends(require_user_creation_permission)], 
    summary="Cria um novo usuário do tipo Aluno."
)
async def criar_novo_aluno(
    user_data: EstudanteConfig, 
    user_model: UserModel = Depends(get_user_model) 
):
    dados_para_inserir = user_data.model_dump()
    
    resultado = user_model.inserir_novo_usuario(dados_para_inserir)
    
    if resultado['status'] == 'error':
        if "Permissão negada" in resultado['message']:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=resultado['message']
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, 
                detail=resultado['message']
            )
            
    return resultado


@router.post(
    "/instrutor", 
    status_code=status.HTTP_201_CREATED,
    response_model=Dict[str, Any], 
    dependencies=[Depends(require_user_creation_permission)], 

    summary="Cria um novo usuário do tipo Instrutor/Professor."
)
async def criar_novo_instrutor(
    user_data: ProfessorConfig, 
    user_model: UserModel = Depends(get_user_model) 
):
    dados_para_inserir = user_data.model_dump()
    resultado = user_model.inserir_novo_usuario(dados_para_inserir)
    if resultado['status'] == 'error':
        if "Permissão negada" in resultado['message']:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=resultado['message']
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, 
                detail=resultado['message']
            )
    return resultado


@router.post(
    "/administracao", 
    status_code=status.HTTP_201_CREATED,
    response_model=Dict[str, Any], 
    dependencies=[Depends(require_user_creation_permission)], 

    summary="Cria um novo usuário de Administração (Colaborador/Supremo)."
)
async def criar_novo_administrador(
    user_data: AdministracaoConfig, 
    
    user_model: UserModel = Depends(get_user_model) 
):
    dados_para_inserir = user_data.model_dump()
    resultado = user_model.inserir_novo_usuario(dados_para_inserir)
    if resultado['status'] == 'error':
        if "Permissão negada" in resultado['message']:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=resultado['message']
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, 
                detail=resultado['message']
            )
    return resultado




"""login"""

class LoginRequest(BaseModel):
    """Modelo de dados de entrada para a requisição de Login."""
    # Garante que o email seja válido (EmailStr)
    email: EmailStr = Field(..., title="Email do Usuário")
    senha: str = Field(..., title="Senha em texto puro")

@router.post(
    "/login", 
    response_model=Dict[str, Any], 
    summary="Realiza o login do usuário e retorna dados de autenticação (JWT)."
)
async def fazer_login_endpoint(
    request: LoginRequest,
    # Reutiliza o get_user_model. O nível do executor não importa no login, só no create.
    user_model: UserModel = Depends(get_user_model) 
):
    
    # Chama a lógica de negócio principal
    usuario_logado = user_model.fazer_login(request.email, request.senha)
    if usuario_logado is None:
        # Se a senha ou email estiverem incorretos, retorna 401
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciais inválidas (Email ou Senha incorretos)."
        )
        
    # ATENÇÃO: É neste ponto que a API deve gerar e retornar um Token JWT (futuramente)
    
    return {
        "message": "Login bem-sucedido.", 
        "user_data": usuario_logado,
        # "access_token": "TOKEN_JWT_AQUI" 
    }